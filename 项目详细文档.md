# 青少年篮球训练视频分析系统 - 详细技术文档

## 目录

1. [项目概述](#项目概述)
2. [系统架构](#系统架构)
3. [技术栈详解](#技术栈详解)
4. [前端系统详解](#前端系统详解)
5. [后端系统详解](#后端系统详解)
6. [核心算法](#核心算法)
7. [部署指南](#部署指南)
8. [开发指南](#开发指南)
9. [API文档](#api文档)
10. [测试指南](#测试指南)
11. [性能优化](#性能优化)
12. [故障排除](#故障排除)
13. [扩展开发](#扩展开发)
14. [项目维护](#项目维护)

---

## 项目概述

### 项目背景
系统以“上传训练视频 → 后端多模型处理 → 前端可视化回放”为主线，帮助教练和家长高效评估运球、投篮、防守三类篮球训练表现。项目集成了 3D 姿态估计、YOLOv8 目标检测、个性化指标计算以及 DeepSeek AI 训练点评，旨在提供科学、自动化、可追踪的训练闭环。

### 核心价值
- **AI 驱动的动作分析**：结合 YOLOv8 与 3D human pose 模型，精准捕捉训练细节。
- **可视化训练档案**：前端通过图表、骨架叠加、趋势曲线等方式呈现关键洞察。
- **教练/家长协同**：内置学员、家长账号流，支持报告生成、推送与历史回溯。
- **开放式扩展**：提供脚本、API、Mock 数据、测试工具，适合快速二次开发。

### 应用场景
- 体校或俱乐部的日常训练评估与动作矫正。
- 校园体育课程的体育数据采集与跟进。
- 家庭训练的辅助指导及家长端反馈。
- 专业教练或康复专家的动作风险排查与档案管理。

---

## 系统架构

### 整体架构图
```
┌────────────────────┐     ┌────────────────────────┐     ┌────────────────────┐
│  前端 Web 应用层   │ ⇄   │   后端分析与推理服务    │ ⇄   │   数据/模型资源层    │
│ React 19 · TS · Vite│     │ Flask API · 多进程调度 │     │ 模型权重 · 视频缓存   │
│ TailwindCSS · Zustand│   │ YOLOv8 · 3D Pose · FFmpeg│    │ uploads/ · outputs/  │
└────────────────────┘     └────────────────────────┘     └────────────────────┘
```

### 数据流架构
```
视频/流媒体 → YOLOv8 目标检测 → 3D 姿态估计 → 指标/AI 分析 → 前端可视化
      ↓              ↓                ↓                ↓               ↓
  uploads/      `main.py:YoloGetMotorTrack`      `InferenceEnginePyTorch`
                                                  `BasketballMetricsCalculator`
                                          DeepSeek/Mock 评语 · 指标存储 · H.264 转码
```

### 模块化设计
- **前端交互层**：React 组件、角色路由、指标可视化、PDF 报表。
- **后端任务层**：Flask API、任务队列、文件管理、FFmpeg 转码。
- **推理与算法层**：YOLOv8 检测、3D 姿态解析、篮球指标计算、AI 智能点评。
- **资源管理层**：模型权重、外参配置、日志、测试脚本与 Mock 数据。

---

## 技术栈详解

### 前端技术栈

| 分类 | 选型 | 说明 |
| ---- | ---- | ---- |
| 核心框架 | React 19、TypeScript、Vite | 支持并发特性、TS 静态类型与快速热更新 |
| UI/交互 | TailwindCSS、shadcn/ui、Radix Primitives、Lucide Icons | 提供可访问性组件、统一设计体系与动态图标 |
| 状态管理 | Zustand、React Router DOM 7 | 轻量全局状态；多角色路由守卫与懒加载 |
| 可视化与导出 | Recharts、html2canvas、jsPDF | 渲染折线/柱状/饼图，支持 PDF 图文报告导出 |
| 工具链 | Vitest、ESLint、Prettier | （可选）前端单元测试与规范约束 |

### 后端技术栈

| 分类 | 选型 | 说明 |
| ---- | ---- | ---- |
| Web 框架 | Flask、Flask-CORS、Werkzeug | REST API、跨域支持、文件上传管理 |
| 视频与数值 | OpenCV、FFmpeg CLI、NumPy | 视频解码/编码、逐帧处理、矩阵运算 |
| 深度学习 | PyTorch、Ultralytics | 加载 3D 姿态网络、YOLOv8 目标检测、GPU 加速 |
| 算法模块 | `modules/`、`scenes/basketball/` | 姿态解析、骨架绘制、一欧滤波、动作指标计算 |
| AI 服务 | DeepSeek API（可选） | 用于生成训练总结及评分，未配置时降级至 Mock |
| 测试/脚本 | `test_*.py`、`export_pose_sequence.py` | 接口测试、FFmpeg 检查、姿态导出等工具 |

> 注：若需接入硬件（如 USB-CAN、云台等），可参考 `usbcanlib/` 与遗留的 `modules/legacy_pose_extractor.py`，当前版本默认以离线视频和文件上传为主。

---

## 前端系统详解

### 项目结构
```
front-end/
├── src/
│   ├── components/           # 上传、指标、图表、播放器等通用组件
│   │   ├── ui/               # shadcn/ui 二次封装
│   │   ├── analytics/        # 指标卡片、趋势图
│   │   ├── reports/          # PDF 报告构建组件
│   │   └── media/VideoPlayerWithOverlay.tsx
│   ├── pages/
│   │   ├── login/            # 登录流程与守卫
│   │   ├── parent/           # 家长视角页面
│   │   └── coach/            # 教练视角（运球/投篮/防守）
│   ├── hooks/                # 自定义 Hook（数据轮询、播放器同步等）
│   ├── lib/                  # `api.ts`、数值工具、格式化函数
│   ├── store/                # Zustand 状态（认证、全局配置、主题）
│   ├── mock/                 # 离线数据、骨架序列示例
│   ├── types/                # TypeScript 类型
│   └── utils/                # 工具函数与常量
```

### 核心组件详解

#### 1. 角色路由与守卫
```typescript
// App.tsx - 路由配置
const ROLE_DEFAULT_PATH: Record<UserRole, string> = {
  parent: '/parent/basketball',
  coach: '/coach/training',
};

function ProtectedRoute({ allowRoles, children }) {
  const user = useAuthStore((state) => state.user);
  if (!user) return <Navigate to="/login" replace />;
  if (!allowRoles.includes(user.role)) {
    return <Navigate to={ROLE_DEFAULT_PATH[user.role]} replace />;
  }
  return children;
}
```

#### 2. 认证系统
```typescript
// store/auth.ts - Zustand状态管理
export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  isLoading: true,
  async login(username, password) {
    // 验证逻辑
    const credential = DEMO_ACCOUNTS.find(item => item.username === username);
    if (!credential || credential.password !== password) {
      return { success: false, message: '账号或密码不正确' };
    }
    // 设置用户状态
    set({ user });
    return { success: true };
  },
  logout() {
    window.localStorage.removeItem(STORAGE_KEY);
    set({ user: null });
  }
}));
```

#### 3. 数据获取与降级策略
```typescript
// lib/api.ts - 优雅降级的数据获取
async function fetchRemoteSessions(): Promise<TrainingSession[] | null> {
  for (const url of remoteSources.basketballSessions) {
    try {
      const data = await tryFetchJson<Array<Record<string, unknown>>>(url);
      // 处理远程数据
      return processedSessions;
    } catch (error) {
      console.warn('远程数据获取失败，使用Mock数据', error);
    }
  }
  return null; // 降级到Mock数据
}
```

#### 4. 视频播放器与骨架叠加
```typescript
// components/VideoPlayerWithOverlay.tsx
export function VideoPlayerWithOverlay({
  videoSrc,
  overlays,
  onFrameUpdate,
  className
}) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  // 实时绘制叠加层
  const drawOverlays = useCallback(() => {
    const canvas = canvasRef.current;
    const video = videoRef.current;
    if (!canvas || !video) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 绘制角度信息、骨架图等
    overlays.forEach(overlay => {
      drawOverlay(ctx, overlay);
    });
  }, [overlays]);
}
```

#### 5. PDF 报告生成
```typescript
// components/ReportBuilder.tsx
export function ReportBuilder({ targetId, fileName, title }) {
  const generatePDF = async () => {
    const element = document.getElementById('report-content');
    const canvas = await html2canvas(element);
    const imgData = canvas.toDataURL('image/png');
    
    const pdf = new jsPDF();
    pdf.addImage(imgData, 'PNG', 0, 0);
    pdf.save(fileName);
  };
}
```

### 页面功能详解

#### 家长端主要功能
- **动作矫正视图**：播放骨架叠加视频，展示指标曲线与角度面板，配合异常提醒。
- **成长档案**：呈现训练里程碑、季度趋势、AI 建议摘要，支持一键 PDF 导出。
- **消息中心（可选）**：接收教练推送的最新报告和训练建议。

#### 教练端主要功能
- **训练分析面板**：上传新视频、查看处理进度、切换训练类型、对指标进行横向对比。
- **学员管理**：在前端选择学员、生成报告并推送至家长端。
- **数据联动**：API 返回的指标与关键点被格式化为时间序列，与 Recharts 图表和骨架播放器同步展示。

---

## 后端系统详解

### 项目结构
```
multi_scene_monitoring/
├── main.py                 # 系统入口
├── modules/                # 核心模块
│   ├── pose.py            # 姿态估计核心
│   ├── draw.py            # 可视化绘制
│   ├── parse_poses.py     # 姿态数据解析
│   └── inference_engine_*.py # 推理引擎
├── models/                 # AI模型定义
├── scenes/                 # 场景分析器
│   ├── basketball/        # 篮球场景
│   └── classroom/         # 课堂场景
├── data/                   # 数据文件
└── usbcanlib/             # 硬件接口
```

### 核心模块详解

#### 1. 多进程架构
```python
# main.py - 进程管理
if __name__ == '__main__':
    processes = []
    
    # 启用不同模块
    if enable_fast3dhp:
        processFast3DHP = Fast3DHP((conn1, conn2), image_queue)
        processFast3DHP.start()
        processes.append(processFast3DHP)
    
    if enable_panorama:
        processCameraTrack = YoloGetMotorTrack(camera_track_queue)
        processCameraTrack.start()
        processes.append(processCameraTrack)
    
    # 等待所有进程结束
    for process in processes:
        process.join()
```

#### 2. 3D姿态估计
```python
class PoseTracker3D:
    def __init__(self):
        model_path = str(PROJECT_ROOT / 'human-pose-estimation-3d.pth')
        self.net = InferenceEnginePyTorch(model_path, 'GPU', use_tensorrt=False)
        
    def run_model(self, img):
        stride = 8
        base_height = 256
        input_scale = base_height / img.shape[0]
        scaled_img = cv2.resize(img, dsize=None, fx=input_scale, fy=input_scale)
        
        inference_result = self.net.infer(scaled_img)
        poses_3d, poses_2d = parse_poses(inference_result, input_scale, stride, fx, is_video=True)
        return poses_3d, poses_2d
```

#### 3. 损伤预警算法
```python
def get_angle_warning(self, poses_3d, canonical_pose=None):
    """关节角度损伤预警"""
    for i in range(pose.shape[0]):
        warning_list = [False] * 19
        
        # 肩膀损伤预警
        angle_r_shoulder_normal = get_angle_3D(pose[i][10] - pose[i][9], vector_front_right)
        if angle_r_shoulder_normal > 80:
            warning_list[9] = True  # 右肩预警
            
        # 肘关节损伤预警
        angle_r_elbow_arm = get_angle_3D(pose[i][9] - pose[i][10], pose[i][11] - pose[i][10])
        if angle_r_elbow_arm < 30:
            warning_list[10] = True  # 右肘预警
            
        # 膝关节损伤预警
        angle_r_knee_normal = get_angle_3D(pose[i][12] - pose[i][13], pose[i][14] - pose[i][13])
        if angle_r_knee_normal < 40:
            warning_list[13] = True  # 右膝预警
```

#### 4. 场景化分析器
```python
# scenes/basketball/analyzer.py
class BasketballAnalyzer(ScenarioAnalyzer):
    def analyze(self, canonical_poses, raw_poses, poses_2d):
        detections = []
        for idx, pose in enumerate(canonical_poses):
            detection = self._detect_shooting(pose, idx)
            if detection:
                detections.append(detection)
        return detections
    
    def _detect_shooting(self, pose, person_idx):
        """检测投篮姿态"""
        up, left_to_right, front = compute_body_basis(pose)
        
        # 评估投篮动作的各项指标
        wrist_height = float(np.dot(wrist - shoulder, up))
        elbow_angle = angle_between(shoulder - elbow, wrist - elbow)
        hand_proximity = 1.0 - min(hand_distance / (shoulder_span * 1.5), 1.0)
        
        # 计算置信度
        score = 0.0
        if wrist_height > 0.15: score += 0.35
        if 45.0 <= elbow_angle <= 140.0: score += 0.30
        if hand_proximity > 0.4: score += 0.20
        
        return Detection(
            person_index=person_idx,
            label="shooting posture",
            confidence=min(score, 1.0),
            description=f"投篮姿态检测，置信度{min(score, 1.0):.2f}"
        )
```

### 硬件接口

#### 1. 摄像头控制
```python
class CameraCap:
    def __init__(self, source=0, *, env_vars=None, allow_default_video=False):
        candidates = build_candidate_sources(preferred=source, env_vars=env_vars)
        for candidate in candidates:
            cap = cv2.VideoCapture(candidate)
            if cap.isOpened():
                self.cap = cap
                self.source = candidate
                break
    
    def get_frame(self):
        ret, frame = self.cap.read()
        return ret, frame
```

#### 2. USB-CAN通信
```python
# usbcanlib/USBCANBase.py
class USBCAN:
    def __init__(self, CanDLLName='./usbcanlib/ControlCAN.dll'):
        self.dll = ctypes.CDLL(CanDLLName)
        self.init_CAN()
    
    def keyboardControl(self, queue):
        """通过CAN总线控制云台"""
        while True:
            try:
                degree_data = queue.get_nowait()
                pitch, yaw = degree_data
                self.send_motor_command(pitch, yaw)
            except Empty:
                pass
```

---

## 核心算法

### 1. 3D姿态估计算法

#### 模型架构
- **输入**: RGB图像 (H×W×3)
- **预处理**: 缩放到256px高度，保持宽高比
- **网络**: 基于HRNet的高分辨率姿态估计网络
- **输出**: 19个关键点的3D坐标 (x, y, z, confidence)

#### 关键点定义
```
0: 鼻尖     7: 左髋     14: 右膝
1: 头顶     8: 左膝     15: 右脚踝
2: 左肩     9: 左脚踝   16: 右肩
3: 左肘    10: 右髋     17: 右肘
4: 左腕    11: 右膝     18: 右腕
5: 右肩    12: 右脚踝
6: 右肘    13: 左肩
```

#### 坐标系转换
```python
def rotate_poses(poses_3d, R, t):
    """将相机坐标系转换到世界坐标系"""
    R_inv = np.linalg.inv(R)
    for pose_id in range(len(poses_3d)):
        pose_3d = poses_3d[pose_id].reshape((-1, 4)).transpose()
        pose_3d[0:3, :] = np.dot(R_inv, pose_3d[0:3, :] - t)
        poses_3d[pose_id] = pose_3d.transpose().reshape(-1)
    return poses_3d
```

### 2. 关节角度计算

#### 角度计算公式
```python
def get_angle_3D(v1, v2):
    """计算两个3D向量之间的夹角"""
    x = np.array(v1)
    y = np.array(v2)
    
    module_x = np.sqrt(x.dot(x))
    module_y = np.sqrt(y.dot(y))
    dot_value = x.dot(y)
    cos_theta = dot_value / (module_x * module_y)
    angle_radian = np.arccos(np.clip(cos_theta, -1.0, 1.0))
    angle_value = angle_radian * 180 / np.pi
    return angle_value
```

#### 关键关节角度
- **肩关节**: 上臂与躯干的夹角
- **肘关节**: 上臂与前臂的夹角
- **髋关节**: 大腿与躯干的夹角
- **膝关节**: 大腿与小腿的夹角

### 3. 损伤预警算法

#### 预警阈值设定
```python
WARNING_THRESHOLDS = {
    'shoulder_angle': 80,      # 肩关节异常角度阈值
    'elbow_min_angle': 30,     # 肘关节最小角度
    'hip_min_angle': 40,       # 髋关节最小角度
    'knee_min_angle': 40,      # 膝关节最小角度
}
```

#### 预警逻辑
1. **肩关节预警**: 手臂与身体前45度方向夹角>80°
2. **肘关节预警**: 手肘与大臂夹角<30°
3. **髋关节预警**: 大腿上抬角度<40°或后翘>10°
4. **膝关节预警**: 膝盖向前伸展>10°或向后屈曲<40°

### 4. 场景识别算法

#### 篮球投篮检测
```python
def _detect_shooting(self, pose, person_idx):
    """投篮姿态检测算法"""
    # 1. 腕部高度检测
    wrist_height = float(np.dot(wrist - shoulder, up))
    
    # 2. 肘部角度检测
    elbow_angle = angle_between(shoulder - elbow, wrist - elbow)
    
    # 3. 双手距离检测
    hand_distance = joint_distance(wrist, opposite_wrist)
    hand_proximity = 1.0 - min(hand_distance / (shoulder_span * 1.5), 1.0)
    
    # 4. 投篮方向检测
    release_forward = float(np.dot(wrist - hip_center, front))
    
    # 综合评分
    score = 0.0
    if wrist_height > 0.15: score += 0.35
    if 45.0 <= elbow_angle <= 140.0: score += 0.30
    if hand_proximity > 0.4: score += 0.20
    if release_forward > 0.05: score += 0.15
    
    return score >= self.min_confidence
```

#### 课堂坐姿检测
```python
def _detect_leaning(self, pose, person_idx):
    """趴桌检测算法"""
    # 1. 躯干前倾角检测
    forward_lean = angle_between(up, chest - hip_center)
    
    # 2. 头部高度检测
    head_height = float(np.dot(head - hip_center, up))
    
    # 3. 头部前移检测
    head_forward = float(np.dot(head - chest, front))
    
    # 综合判断
    if forward_lean > 30 and head_height < 0.3 and head_forward > 0.1:
        return Detection(
            person_index=person_idx,
            label="leaning on desk",
            confidence=0.8,
            description="检测到趴桌行为"
        )
```

---

## 部署指南

### 环境要求

#### 前端环境
- **Node.js**: 18.0+ 
- **npm**: 8.0+ 或 yarn 1.22+
- **现代浏览器**: Chrome 90+, Firefox 88+, Safari 14+

#### 后端环境
- **Python**: 3.8-3.11
- **操作系统**: Windows 10+, Ubuntu 18.04+, macOS 10.15+
- **GPU**: NVIDIA GPU (可选，用于加速推理)
- **内存**: 8GB+ RAM
- **存储**: 10GB+ 可用空间

### 前端部署

#### 开发环境部署
```bash
# 1. 克隆项目
git clone https://gitee.com/ChunYang_2024/c-assessment.git
cd c-assessment/front-end

# 2. 安装依赖
npm install

# 3. 启动开发服务器
npm run dev

# 4. 访问应用
# 浏览器打开 http://localhost:5173
```

#### 生产环境部署
```bash
# 1. 构建生产版本
npm run build

# 2. 预览构建结果
npm run preview

# 3. 部署到Web服务器
# 将 dist/ 目录内容部署到 Nginx/Apache 等
```

#### Docker部署
```dockerfile
# Dockerfile
FROM node:18-alpine as builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 后端部署

#### 环境配置
```bash
# 1. 创建Python虚拟环境
python -m venv venv
source venv/bin/activate  # Linux/macOS
# 或
venv\Scripts\activate  # Windows

# 2. 安装依赖
pip install -r multi_scene_monitoring/requirements_tiaobei.txt

# 3. 下载模型文件
# 确保 human-pose-estimation-3d.pth 和 yolov8n.pt 在正确位置
```

#### 运行配置
```bash
# 基础运行
cd multi_scene_monitoring
python main.py

# 环境变量配置
export SCENE=basketball          # 设置场景
export FAST3DHP_SOURCE=0         # 设置摄像头输入
export ENABLE_FAST3DHP=1         # 启用姿态估计
export ENABLE_PANORAMA=0         # 禁用全景跟踪
export ENABLE_USBCAN=0           # 禁用CAN通信

python main.py
```

#### 服务化部署
```bash
# 创建systemd服务文件
sudo nano /etc/systemd/system/pose-monitoring.service

[Unit]
Description=Multi-scene Activity Monitoring
After=network.target

[Service]
Type=simple
User=ubuntu
WorkingDirectory=/opt/pose-monitoring
Environment=PATH=/opt/pose-monitoring/venv/bin
ExecStart=/opt/pose-monitoring/venv/bin/python main.py
Restart=always

[Install]
WantedBy=multi-user.target

# 启用服务
sudo systemctl enable pose-monitoring
sudo systemctl start pose-monitoring
```

### 硬件配置

#### 摄像头配置
```python
# 支持多种输入源
VIDEO_SOURCE=0                 # USB摄像头
VIDEO_SOURCE=rtsp://...        # RTSP流
VIDEO_SOURCE=http://...         # HTTP流
VIDEO_SOURCE=/path/to/video    # 视频文件
```

#### USB-CAN设备配置
```bash
# 1. 安装驱动
# Windows: 自动安装ControlCAN.dll
# Linux: 安装对应内核模块

# 2. 配置设备权限
sudo usermod -a -G dialout $USER
sudo chmod 666 /dev/ttyUSB*
```

---

## 开发指南

### 前端开发

#### 项目结构说明
```
src/
├── components/          # 可复用组件
│   ├── ui/             # 基础UI组件 (shadcn/ui)
│   ├── business/       # 业务组件
│   └── layout/         # 布局组件
├── pages/              # 页面组件
├── hooks/              # 自定义Hook
├── lib/                # 工具库和API
├── store/              # 状态管理
├── types/              # TypeScript类型
└── utils/              # 工具函数
```

#### 开发规范

##### 组件开发规范
```typescript
// 组件模板
import { ReactElement } from 'react';
import { cn } from '@/lib/utils';

interface ComponentProps {
  // 属性定义
  className?: string;
  children?: React.ReactNode;
}

export function Component({ 
  className, 
  children, 
  ...props 
}: ComponentProps): ReactElement {
  return (
    <div className={cn("base-styles", className)} {...props}>
      {children}
    </div>
  );
}
```

##### Hook开发规范
```typescript
// 自定义Hook模板
import { useState, useEffect, useCallback } from 'react';

interface UseHookOptions {
  // 选项定义
}

interface UseHookReturn {
  // 返回值定义
}

export function useHook(options: UseHookOptions): UseHookReturn {
  const [state, setState] = useState();
  
  const callback = useCallback(() => {
    // 逻辑实现
  }, [dependencies]);
  
  useEffect(() => {
    // 副作用
    return () => {
      // 清理
    };
  }, [dependencies]);
  
  return {
    state,
    callback
  };
}
```

#### 状态管理规范
```typescript
// Zustand Store模板
interface StoreState {
  // 状态定义
  data: any[];
  loading: boolean;
  error: string | null;
  
  // 动作定义
  fetchData: () => Promise<void>;
  clearData: () => void;
}

export const useStore = create<StoreState>((set, get) => ({
  data: [],
  loading: false,
  error: null,
  
  fetchData: async () => {
    set({ loading: true, error: null });
    try {
      const result = await api.fetchData();
      set({ data: result, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },
  
  clearData: () => set({ data: [] })
}));
```

#### API开发规范
```typescript
// API函数模板
interface ApiResponse<T> {
  data: T;
  message?: string;
  success: boolean;
}

export async function apiFunction<T>(
  params: any
): Promise<ApiResponse<T>> {
  try {
    const response = await fetch('/api/endpoint', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(params),
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
}
```

### 后端开发

#### 模块开发规范
```python
# 模块模板
from typing import List, Optional, Dict, Any
import numpy as np
import cv2

class ModuleBase:
    """模块基类"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self._initialize()
    
    def _initialize(self):
        """初始化模块"""
        pass
    
    def process(self, input_data: Any) -> Any:
        """处理输入数据"""
        raise NotImplementedError
    
    def cleanup(self):
        """清理资源"""
        pass
```

#### 场景分析器开发
```python
# 新场景分析器模板
from scenes.base import ScenarioAnalyzer, Detection

class CustomAnalyzer(ScenarioAnalyzer):
    name = "custom_scene"
    
    def __init__(self, min_confidence: float = 0.6):
        self.min_confidence = min_confidence
        self._load_models()
    
    def _load_models(self):
        """加载模型"""
        pass
    
    def analyze(self, canonical_poses, raw_poses, poses_2d) -> List[Detection]:
        """分析场景"""
        detections = []
        
        for idx, pose in enumerate(canonical_poses):
            detection = self._detect_action(pose, idx)
            if detection:
                detections.append(detection)
        
        return detections
    
    def _detect_action(self, pose, person_idx) -> Optional[Detection]:
        """检测特定动作"""
        # 实现检测逻辑
        pass

# 注册分析器
def create_analyzer() -> ScenarioAnalyzer:
    return CustomAnalyzer()
```

#### 配置管理
```python
# config.py
import os
from pathlib import Path
from typing import Dict, Any

class Config:
    """配置管理类"""
    
    def __init__(self):
        self.project_root = Path(__file__).parent.parent
        self._load_env()
    
    def _load_env(self):
        """加载环境变量"""
        self.scene_name = os.getenv('SCENE', '').strip().lower()
        self.enable_fast3dhp = self._env_flag('ENABLE_FAST3DHP', True)
        self.enable_panorama = self._env_flag('ENABLE_PANORAMA', False)
        self.enable_usbcan = self._env_flag('ENABLE_USBCAN', False)
    
    def _env_flag(self, name: str, default: bool = False) -> bool:
        """解析布尔环境变量"""
        value = os.getenv(name)
        if value is None:
            return default
        return value.strip().lower() in ('1', 'true', 'yes', 'on')
    
    @property
    def model_paths(self) -> Dict[str, str]:
        """模型文件路径"""
        return {
            'pose_3d': str(self.project_root / 'human-pose-estimation-3d.pth'),
            'yolo': str(self.project_root / 'yolov8n.pt'),
            'extrinsics': str(self.project_root / 'data' / 'extrinsics.json')
        }

config = Config()
```

---

## API文档

### 前端API接口

#### 认证接口
```typescript
// 登录接口
interface LoginRequest {
  username: string;
  password: string;
}

interface LoginResponse {
  success: boolean;
  message?: string;
  user?: AuthUser;
}

// 使用示例
const result = await useAuthStore.getState().login('parent001', '123456');
```

#### 数据获取接口
```typescript
// 获取训练会话数据
interface TrainingSession {
  id: string;
  athleteId: string;
  phase: BasketballPhase;
  points: BasketballMetricPoint[];
  feedback: string[];
}

const sessions = await getTrainingSessions();

// 获取团队概览
interface TeamOverview {
  id: string;
  name: string;
  coach: string;
  members: TeamMemberSnapshot[];
  progressRate: number;
  complianceScore: number;
  riskSummary: RiskSummary;
  monthlyProgress: TrendPoint[];
}

const overview = await getTeamOverview();
```

#### 数据类型定义
```typescript
// 篮球指标点
interface BasketballMetricPoint {
  timestamp: string;
  wristAngle: number;        // 手腕角度
  elbowAngle: number;        // 肘部角度
  shoulderAngle: number;     // 肩膀角度
  kneeAngle: number;         // 膝盖角度
  ballHeight: number;        // 球高度
  dribbleFrequency: number;  // 运球频率
  centerOfMass: number;      // 重心
  verticalVelocity: number;  // 垂直速度
  shootingAccuracy: number;  // 投篮准确度
}

// 学生档案
interface StudentProfile {
  id: string;
  name: string;
  age: number;
  height: number;
  weight: number;
  role: UserRole;
  className?: string;
  teamName?: string;
  avatar?: string;
}
```

### 后端API接口

#### 姿态估计接口
```python
class PoseEstimator:
    def estimate(self, image: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        估计图像中的人体姿态
        
        Args:
            image: 输入图像 (H, W, 3)
            
        Returns:
            poses_3d: 3D姿态 (N, 19, 4)
            poses_2d: 2D姿态 (N, 19, 3)
        """
        pass
    
    def get_angles(self, poses_3d: np.ndarray) -> List[Dict[str, float]]:
        """
        计算关节角度
        
        Args:
            poses_3d: 3D姿态数据
            
        Returns:
            angles: 关键关节角度列表
        """
        pass
```

#### 场景分析接口
```python
class ScenarioAnalyzer:
    def analyze(self, canonical_poses, raw_poses, poses_2d) -> List[Detection]:
        """
        分析特定场景
        
        Args:
            canonical_poses: 标准化姿态
            raw_poses: 原始姿态
            poses_2d: 2D姿态
            
        Returns:
            detections: 检测结果列表
        """
        pass

class Detection:
    def __init__(self, person_index: int, label: str, confidence: float, description: str):
        self.person_index = person_index
        self.label = label
        self.confidence = confidence
        self.description = description
```

#### 硬件控制接口
```python
class CameraController:
    def __init__(self, source: Union[int, str]):
        self.source = source
        self.cap = None
    
    def get_frame(self) -> Tuple[bool, np.ndarray]:
        """获取一帧图像"""
        pass
    
    def release(self):
        """释放摄像头"""
        pass

class MotorController:
    def send_command(self, pitch: float, yaw: float):
        """
        发送云台控制命令
        
        Args:
            pitch: 俯仰角
            yaw: 偏航角
        """
        pass
```

---

## 测试指南

### 前端测试

#### 单元测试
```bash
# 安装测试依赖
npm install --save-dev @testing-library/react @testing-library/jest-dom jest

# 运行测试
npm test
```

#### 测试示例
```typescript
// components/__tests__/AnglePanel.test.tsx
import { render, screen } from '@testing-library/react';
import { AnglePanel } from '../AnglePanel';

describe('AnglePanel', () => {
  test('renders angle values correctly', () => {
    const angles = {
      wrist: 45,
      elbow: 90,
      shoulder: 120
    };
    
    render(<AnglePanel angles={angles} />);
    
    expect(screen.getByText('手腕角度')).toBeInTheDocument();
    expect(screen.getByText('45°')).toBeInTheDocument();
    expect(screen.getByText('肘部角度')).toBeInTheDocument();
    expect(screen.getByText('90°')).toBeInTheDocument();
  });
});
```

#### 集成测试
```typescript
// pages/__tests__/Login.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import LoginPage from '../Login';

const renderWithRouter = (component: React.ReactElement) => {
  return render(
    <BrowserRouter>
      {component}
    </BrowserRouter>
  );
};

describe('LoginPage', () => {
  test('successful login redirects to dashboard', async () => {
    renderWithRouter(<LoginPage />);
    
    fireEvent.change(screen.getByLabelText('用户名'), {
      target: { value: 'parent001' }
    });
    fireEvent.change(screen.getByLabelText('密码'), {
      target: { value: '123456' }
    });
    fireEvent.click(screen.getByRole('button', { name: '登录' }));
    
    await waitFor(() => {
      expect(window.location.pathname).toBe('/parent/basketball');
    });
  });
});
```

### 后端测试

#### 单元测试
```python
# tests/test_pose_estimator.py
import unittest
import numpy as np
from modules.pose import PoseTracker3D

class TestPoseEstimator(unittest.TestCase):
    def setUp(self):
        self.pose_tracker = PoseTracker3D()
        self.test_image = np.zeros((480, 640, 3), dtype=np.uint8)
    
    def test_pose_estimation(self):
        poses_3d, poses_2d = self.pose_tracker.run_model(self.test_image)
        self.assertIsInstance(poses_3d, np.ndarray)
        self.assertIsInstance(poses_2d, np.ndarray)
    
    def test_angle_calculation(self):
        # 测试角度计算
        v1 = [1, 0, 0]
        v2 = [0, 1, 0]
        angle = get_angle_3D(v1, v2)
        self.assertAlmostEqual(angle, 90.0, places=1)

if __name__ == '__main__':
    unittest.main()
```

#### 集成测试
```python
# tests/test_scene_analyzer.py
import unittest
import numpy as np
from scenes.basketball.analyzer import BasketballAnalyzer

class TestBasketballAnalyzer(unittest.TestCase):
    def setUp(self):
        self.analyzer = BasketballAnalyzer()
        # 创建测试姿态数据
        self.test_pose = np.random.rand(19, 3) * 2 - 1
    
    def test_shooting_detection(self):
        detection = self.analyzer._detect_shooting(self.test_pose, 0)
        # 验证检测结果
        if detection:
            self.assertIn('shooting', detection.label)
            self.assertGreaterEqual(detection.confidence, 0)
            self.assertLessEqual(detection.confidence, 1)

if __name__ == '__main__':
    unittest.main()
```

#### 性能测试
```python
# tests/test_performance.py
import time
import unittest
import numpy as np
from modules.pose import PoseTracker3D

class TestPerformance(unittest.TestCase):
    def setUp(self):
        self.pose_tracker = PoseTracker3D()
        self.test_image = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
    
    def test_inference_speed(self):
        start_time = time.time()
        
        # 运行100次推理
        for _ in range(100):
            poses_3d, poses_2d = self.pose_tracker.run_model(self.test_image)
        
        end_time = time.time()
        avg_time = (end_time - start_time) / 100
        
        # 验证平均推理时间小于100ms
        self.assertLess(avg_time, 0.1, f"推理时间过长: {avg_time:.3f}s")

if __name__ == '__main__':
    unittest.main()
```

### 端到端测试

#### 前端E2E测试
```typescript
// e2e/login.spec.ts
import { test, expect } from '@playwright/test';

test('user login flow', async ({ page }) => {
  await page.goto('http://localhost:5173');
  
  // 填写登录表单
  await page.fill('input[name="username"]', 'parent001');
  await page.fill('input[name="password"]', '123456');
  await page.click('button[type="submit"]');
  
  // 验证跳转到家长端页面
  await expect(page).toHaveURL('/parent/basketball');
  await expect(page.locator('h1')).toContainText('篮球动作矫正');
});
```

#### 系统集成测试
```python
# tests/test_integration.py
import unittest
import requests
import json
from multi_scene_monitoring.main import main

class TestIntegration(unittest.TestCase):
    def test_api_integration(self):
        # 测试前后端API集成
        response = requests.get('http://localhost:3000/api/sessions')
        self.assertEqual(response.status_code, 200)
        
        data = response.json()
        self.assertIsInstance(data, list)
    
    def test_video_processing_pipeline(self):
        # 测试完整的视频处理流程
        test_video_path = 'data/test_video.mp4'
        
        # 启动处理
        # ... 启动后端处理的代码
        
        # 验证结果
        # ... 验证处理结果的代码

if __name__ == '__main__':
    unittest.main()
```

---

## 性能优化

### 前端优化

#### 代码分割
```typescript
// 路由级别的代码分割
import { lazy, Suspense } from 'react';

const ParentTabs = lazy(() => import('@/pages/ParentTabs'));
const CoachTabs = lazy(() => import('@/pages/CoachTabs'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/parent/*" element={<ParentTabs />} />
        <Route path="/coach/*" element={<CoachTabs />} />
      </Routes>
    </Suspense>
  );
}
```

#### 组件优化
```typescript
// 使用React.memo优化组件渲染
import React, { memo, useMemo, useCallback } from 'react';

interface OptimizedComponentProps {
  data: any[];
  onItemClick: (item: any) => void;
}

export const OptimizedComponent = memo<OptimizedComponentProps>(({ 
  data, 
  onItemClick 
}) => {
  // 使用useMemo缓存计算结果
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      computed: expensiveCalculation(item)
    }));
  }, [data]);
  
  // 使用useCallback缓存事件处理函数
  const handleClick = useCallback((item) => {
    onItemClick(item);
  }, [onItemClick]);
  
  return (
    <div>
      {processedData.map(item => (
        <div key={item.id} onClick={() => handleClick(item)}>
          {item.computed}
        </div>
      ))}
    </div>
  );
});
```

#### 状态管理优化
```typescript
// 使用选择器优化订阅
import { useAuthStore } from '@/store/auth';

// 避免不必要的重渲染
function UserProfile() {
  // 只订阅需要的字段
  const userName = useAuthStore(state => state.user?.name);
  const logout = useAuthStore(state => state.logout);
  
  return (
    <div>
      <span>{userName}</span>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

#### 图片和资源优化
```typescript
// 图片懒加载
import { useState, useRef, useEffect } from 'react';

function LazyImage({ src, alt, className }) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  return (
    <div ref={imgRef} className={className}>
      {isInView && (
        <img
          src={src}
          alt={alt}
          onLoad={() => setIsLoaded(true)}
          style={{ opacity: isLoaded ? 1 : 0 }}
        />
      )}
    </div>
  );
}
```

### 后端优化

#### 模型推理优化
```python
# 使用TensorRT加速推理
class OptimizedPoseEstimator:
    def __init__(self, model_path: str):
        import torch
        from torch2trt import torch2trt
        
        # 加载PyTorch模型
        self.model = self.load_pytorch_model(model_path)
        
        # 转换为TensorRT
        self.model_trt = torch2trt(
            self.model, 
            [example_input], 
            fp16_mode=True
        )
    
    def infer(self, image: np.ndarray) -> np.ndarray:
        """使用TensorRT进行快速推理"""
        # 预处理
        input_tensor = self.preprocess(image)
        
        # TensorRT推理
        with torch.no_grad():
            output = self.model_trt(input_tensor)
        
        # 后处理
        return self.postprocess(output)
```

#### 多进程优化
```python
# 优化进程间通信
import multiprocessing as mp
from multiprocessing import shared_memory

class SharedMemoryManager:
    def __init__(self, shape: tuple, dtype: np.dtype):
        self.shape = shape
        self.dtype = dtype
        self.size = np.prod(shape) * np.dtype(dtype).itemsize
        
        # 创建共享内存
        self.shared_mem = shared_memory.SharedMemory(create=True, size=self.size)
        self.array = np.ndarray(shape, dtype=dtype, buffer=self.shared_mem.buf)
    
    def write_frame(self, frame: np.ndarray):
        """写入帧数据到共享内存"""
        np.copyto(self.array, frame)
    
    def read_frame(self) -> np.ndarray:
        """从共享内存读取帧数据"""
        return self.array.copy()
    
    def cleanup(self):
        """清理共享内存"""
        self.shared_mem.close()
        self.shared_mem.unlink()
```

#### 缓存优化
```python
# 结果缓存
from functools import lru_cache
import pickle
import hashlib

class ResultCache:
    def __init__(self, cache_dir: str = './cache'):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(exist_ok=True)
    
    def _get_cache_key(self, data: any) -> str:
        """生成缓存键"""
        data_str = pickle.dumps(data)
        return hashlib.md5(data_str).hexdigest()
    
    def get(self, key: str) -> any:
        """获取缓存结果"""
        cache_file = self.cache_dir / f"{key}.pkl"
        if cache_file.exists():
            with open(cache_file, 'rb') as f:
                return pickle.load(f)
        return None
    
    def set(self, key: str, value: any):
        """设置缓存结果"""
        cache_file = self.cache_dir / f"{key}.pkl"
        with open(cache_file, 'wb') as f:
            pickle.dump(value, f)

# 使用缓存
@lru_cache(maxsize=128)
def expensive_calculation(input_data: str) -> float:
    """缓存计算结果"""
    # 复杂计算逻辑
    return result
```

#### 内存优化
```python
# 内存池管理
class MemoryPool:
    def __init__(self, max_size: int = 100):
        self.pool = []
        self.max_size = max_size
    
    def get_array(self, shape: tuple, dtype: np.dtype) -> np.ndarray:
        """从池中获取数组"""
        for i, arr in enumerate(self.pool):
            if arr.shape == shape and arr.dtype == dtype:
                return self.pool.pop(i)
        return np.empty(shape, dtype=dtype)
    
    def return_array(self, arr: np.ndarray):
        """归还数组到池中"""
        if len(self.pool) < self.max_size:
            self.pool.append(arr)

# 使用内存池
memory_pool = MemoryPool()

def process_frame(frame: np.ndarray) -> np.ndarray:
    # 从池中获取临时数组
    temp_array = memory_pool.get_array(frame.shape, frame.dtype)
    
    try:
        # 处理逻辑
        np.copyto(temp_array, frame)
        result = apply_filters(temp_array)
        return result
    finally:
        # 归还数组到池中
        memory_pool.return_array(temp_array)
```

---

## 故障排除

### 前端常见问题

#### 1. 构建失败
```bash
# 问题: TypeScript类型错误
Error: Type 'string' is not assignable to type 'UserRole'

# 解决方案: 检查类型定义
interface AuthUser {
  role: UserRole; // 确保'parent' | 'coach'类型正确
}
```

#### 2. 状态管理问题
```typescript
// 问题: Zustand状态不更新
// 解决方案: 检查状态更新逻辑
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })), // 使用函数式更新
}));
```

#### 3. 路由问题
```typescript
// 问题: 路由不匹配
// 解决方案: 检查路由配置
<Routes>
  <Route path="/parent/*" element={<ParentTabs />} />
  {/* 确保使用通配符匹配子路由 */}
</Routes>
```

#### 4. 样式问题
```css
/* 问题: TailwindCSS样式不生效 */
/* 解决方案: 检查配置 */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 确保在main.css中包含以上指令 */
```

### 后端常见问题

#### 1. 模型加载失败
```python
# 问题: 模型文件不存在
FileNotFoundError: [Errno 2] No such file or directory: 'human-pose-estimation-3d.pth'

# 解决方案: 检查文件路径
model_path = Path(__file__).parent / 'models' / 'human-pose-estimation-3d.pth'
if not model_path.exists():
    raise FileNotFoundError(f"模型文件不存在: {model_path}")
```

#### 2. 摄像头无法打开
```python
# 问题: 摄像头索引错误
cv2.error: OpenCV(4.7.0) :-1: error: (-5:Bad argument)

# 解决方案: 自动检测可用摄像头
def find_available_camera():
    for i in range(10):
        cap = cv2.VideoCapture(i)
        if cap.isOpened():
            cap.release()
            return i
    return None

camera_index = find_available_camera()
if camera_index is None:
    raise RuntimeError("未找到可用摄像头")
```

#### 3. 内存泄漏
```python
# 问题: 内存持续增长
# 解决方案: 及时释放资源
def process_video(video_path: str):
    cap = cv2.VideoCapture(video_path)
    try:
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            # 处理帧
            yield process_frame(frame)
    finally:
        cap.release()  # 确保释放摄像头
```

#### 4. 进程间通信问题
```python
# 问题: 进程死锁
# 解决方案: 设置超时和异常处理
def safe_queue_get(queue, timeout=1.0):
    try:
        return queue.get(timeout=timeout)
    except Empty:
        return None
    except Exception as e:
        print(f"队列获取失败: {e}")
        return None
```

### 系统集成问题

#### 1. 端口冲突
```bash
# 问题: 端口被占用
Error: listen EADDRINUSE :::3000

# 解决方案: 查找并结束占用进程
# Windows
netstat -ano | findstr :3000
taskkill /PID <PID> /F

# Linux/macOS
lsof -ti:3000 | xargs kill -9
```

#### 2. 跨域问题
```typescript
// 问题: CORS错误
Access to fetch at 'http://localhost:8000' has been blocked by CORS policy

// 解决方案: 配置代理
// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true
      }
    }
  }
});
```

#### 3. 环境变量问题
```python
# 问题: 环境变量未设置
KeyError: 'SCENE'

# 解决方案: 设置默认值
scene_name = os.getenv('SCENE', 'basketball').strip().lower()
```

### 性能问题诊断

#### 前端性能分析
```typescript
// 使用React DevTools Profiler
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration) {
  console.log('Component render time:', actualDuration);
}

<Profiler id="App" onRender={onRenderCallback}>
  <App />
</Profiler>
```

#### 后端性能分析
```python
# 使用cProfile分析性能
import cProfile
import pstats

def profile_function(func):
    def wrapper(*args, **kwargs):
        pr = cProfile.Profile()
        pr.enable()
        result = func(*args, **kwargs)
        pr.disable()
        
        stats = pstats.Stats(pr)
        stats.sort_stats('cumulative')
        stats.print_stats(10)
        
        return result
    return wrapper

@profile_function
def process_frames():
    # 处理逻辑
    pass
```

---

## 扩展开发

### 新增场景分析器

#### 1. 创建场景分析器
```python
# scenes/football/analyzer.py
from typing import List, Optional
import numpy as np
from scenes.base import Detection, ScenarioAnalyzer

class FootballAnalyzer(ScenarioAnalyzer):
    name = "football"
    
    def __init__(self, min_confidence: float = 0.7):
        self.min_confidence = min_confidence
        self._load_models()
    
    def _load_models(self):
        """加载足球场景专用模型"""
        # 加载足球动作识别模型
        pass
    
    def analyze(self, canonical_poses, raw_poses, poses_2d) -> List[Detection]:
        """分析足球场景"""
        detections = []
        
        for idx, pose in enumerate(canonical_poses):
            # 检测踢球动作
            kick_detection = self._detect_kicking(pose, idx)
            if kick_detection:
                detections.append(kick_detection)
            
            # 检测头球动作
            header_detection = self._detect_heading(pose, idx)
            if header_detection:
                detections.append(header_detection)
        
        return detections
    
    def _detect_kicking(self, pose, person_idx) -> Optional[Detection]:
        """检测踢球动作"""
        # 实现踢球动作检测逻辑
        # 1. 分析腿部姿态
        # 2. 计算踢球角度
        # 3. 评估动作规范性
        pass
    
    def _detect_heading(self, pose, person_idx) -> Optional[Detection]:
        """检测头球动作"""
        # 实现头球动作检测逻辑
        pass

def create_analyzer() -> ScenarioAnalyzer:
    return FootballAnalyzer()
```

#### 2. 注册场景分析器
```python
# scenes/scene_loader.py
ANALYZER_REGISTRY = {
    'basketball': lambda: BasketballAnalyzer(),
    'classroom': lambda: ClassroomAnalyzer(),
    'football': lambda: FootballAnalyzer(),  # 新增足球场景
}

def load_analyzer(scene_name: str) -> Optional[ScenarioAnalyzer]:
    """加载场景分析器"""
    if scene_name in ANALYZER_REGISTRY:
        return ANALYZER_REGISTRY[scene_name]()
    return None
```

#### 3. 配置场景参数
```python
# scenes/football/config.py
class FootballConfig:
    """足球场景配置"""
    
    # 踢球动作阈值
    KICKING_LEG_ANGLE_MIN = 45
    KICKING_LEG_ANGLE_MAX = 120
    KICKING_HEIGHT_MIN = 0.2
    
    # 头球动作阈值
    HEADING_HEIGHT_MIN = 0.5
    HEADING_FORWARD_ANGLE_MIN = 30
    
    # 置信度阈值
    MIN_CONFIDENCE = 0.7
```

### 新增前端页面

#### 1. 创建页面组件
```typescript
// pages/FootballTabs.tsx
import { useState } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { RoleTabsLayout } from '@/components/RoleTabsLayout';

function FootballTrainingTab() {
  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold">足球训练监测</h2>
      {/* 足球训练相关组件 */}
    </div>
  );
}

function FootballAnalysisTab() {
  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold">技术动作分析</h2>
      {/* 足球动作分析组件 */}
    </div>
  );
}

export default function FootballTabs() {
  const tabs = [
    { key: 'training', label: '训练监测', component: FootballTrainingTab },
    { key: 'analysis', label: '动作分析', component: FootballAnalysisTab },
  ];

  return (
    <RoleTabsLayout
      tabs={tabs}
      activeKey="training"
      title="足球训练系统"
      subtitle="专业的足球技术动作监测与分析"
    />
  );
}
```

#### 2. 添加路由配置
```typescript
// App.tsx
import FootballTabs from '@/pages/FootballTabs';

function App() {
  return (
    <Routes>
      {/* 现有路由 */}
      <Route path="/parent/*" element={<ParentTabs />} />
      <Route path="/coach/*" element={<CoachTabs />} />
      
      {/* 新增足球路由 */}
      <Route
        path="/football/*"
        element={
          <ProtectedRoute allowRoles={['coach']}>
            <FootballTabs />
          </ProtectedRoute>
        }
      />
    </Routes>
  );
}
```

### 新增硬件支持

#### 1. 添加新硬件接口
```python
# hardware/kinect_controller.py
import numpy as np
from typing import Tuple, Optional

class KinectController:
    """Kinect深度摄像头控制器"""
    
    def __init__(self):
        self.device = None
        self._initialize()
    
    def _initialize(self):
        """初始化Kinect设备"""
        try:
            # 初始化Kinect SDK
            import pykinect2
            from pykinect2.PyKinectV2 import PyKinectV2
            
            self.device = PyKinectV2()
            self.device.open()
        except ImportError:
            raise ImportError("请安装pykinect2库")
        except Exception as e:
            raise RuntimeError(f"Kinect初始化失败: {e}")
    
    def get_depth_frame(self) -> Optional[np.ndarray]:
        """获取深度图像"""
        if not self.device:
            return None
        
        # 获取深度数据
        depth_frame = self.device.get_last_depth_frame()
        if depth_frame is None:
            return None
        
        # 转换为numpy数组
        depth_array = np.frombuffer(depth_frame, dtype=np.uint16)
        depth_array = depth_array.reshape((424, 512))
        
        return depth_array
    
    def get_color_frame(self) -> Optional[np.ndarray]:
        """获取彩色图像"""
        if not self.device:
            return None
        
        color_frame = self.device.get_last_color_frame()
        if color_frame is None:
            return None
        
        color_array = np.frombuffer(color_frame, dtype=np.uint8)
        color_array = color_array.reshape((1080, 1920, 4))
        color_array = color_array[:, :, :3]  # 移除alpha通道
        
        return color_array
    
    def get_skeleton_data(self) -> Optional[list]:
        """获取骨骼数据"""
        if not self.device:
            return None
        
        bodies = self.device.get_last_body_frame()
        if bodies is None:
            return None
        
        skeletons = []
        for i in range(bodies.body_count):
            if bodies.bodies[i].is_tracked:
                joints = bodies.bodies[i].joints
                skeletons.append(joints)
        
        return skeletons
    
    def release(self):
        """释放设备"""
        if self.device:
            self.device.close()
```

#### 2. 集成到主程序
```python
# main.py
from hardware.kinect_controller import KinectController

class KinectInput(Process):
    def __init__(self, queue):
        Process.__init__(self)
        self.queue = queue
        self.kinect = None
    
    def run(self):
        try:
            self.kinect = KinectController()
            
            while True:
                # 获取深度图像
                depth_frame = self.kinect.get_depth_frame()
                if depth_frame is not None:
                    # 处理深度数据
                    processed_frame = self._process_depth_frame(depth_frame)
                    self.queue.put(processed_frame)
                
                # 获取骨骼数据
                skeleton_data = self.kinect.get_skeleton_data()
                if skeleton_data:
                    # 处理骨骼数据
                    self.queue.put(('skeleton', skeleton_data))
                
                time.sleep(0.03)  # 30 FPS
                
        except KeyboardInterrupt:
            print("Kinect输入进程停止")
        finally:
            if self.kinect:
                self.kinect.release()
    
    def _process_depth_frame(self, depth_frame: np.ndarray) -> np.ndarray:
        """处理深度图像"""
        # 深度图像处理逻辑
        return processed_frame
```

### 数据库集成

#### 1. 数据库模型设计
```python
# models/database.py
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class Athlete(Base):
    __tablename__ = 'athletes'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    age = Column(Integer)
    height = Column(Float)
    weight = Column(Float)
    team_id = Column(Integer, ForeignKey('teams.id'))
    created_at = Column(DateTime, default=datetime.utcnow)

class TrainingSession(Base):
    __tablename__ = 'training_sessions'
    
    id = Column(Integer, primary_key=True)
    athlete_id = Column(Integer, ForeignKey('athletes.id'))
    session_type = Column(String(50))  # basketball, football, etc.
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime)
    metrics = Column(Text)  # JSON格式存储指标数据

class PoseData(Base):
    __tablename__ = 'pose_data'
    
    id = Column(Integer, primary_key=True)
    session_id = Column(Integer, ForeignKey('training_sessions.id'))
    timestamp = Column(Float)  # 相对于会话开始的时间戳
    keypoints = Column(Text)  # JSON格式存储关键点数据
    angles = Column(Text)     # JSON格式存储角度数据
    confidence = Column(Float)
```

#### 2. 数据访问层
```python
# dao/session_dao.py
from sqlalchemy.orm import Session
from models.database import TrainingSession, PoseData
from typing import List, Optional

class SessionDAO:
    def __init__(self, session: Session):
        self.session = session
    
    def create_session(self, athlete_id: int, session_type: str) -> TrainingSession:
        """创建训练会话"""
        training_session = TrainingSession(
            athlete_id=athlete_id,
            session_type=session_type,
            start_time=datetime.utcnow()
        )
        self.session.add(training_session)
        self.session.commit()
        return training_session
    
    def save_pose_data(self, session_id: int, pose_data: dict) -> PoseData:
        """保存姿态数据"""
        pose_record = PoseData(
            session_id=session_id,
            timestamp=pose_data['timestamp'],
            keypoints=json.dumps(pose_data['keypoints']),
            angles=json.dumps(pose_data['angles']),
            confidence=pose_data['confidence']
        )
        self.session.add(pose_record)
        self.session.commit()
        return pose_record
    
    def get_session_history(self, athlete_id: int, limit: int = 10) -> List[TrainingSession]:
        """获取训练历史"""
        return self.session.query(TrainingSession)\
            .filter_by(athlete_id=athlete_id)\
            .order_by(TrainingSession.start_time.desc())\
            .limit(limit)\
            .all()
```

---

## 项目维护

### 代码维护

#### 1. 代码质量检查
```bash
# 前端代码检查
npm run lint          # ESLint检查
npm run type-check    # TypeScript类型检查
npm run format        # Prettier格式化

# 后端代码检查
pip install flake8 black mypy
flake8 multi_scene_monitoring/          # Python代码风格检查
black multi_scene_monitoring/           # 代码格式化
mypy multi_scene_monitoring/            # 类型检查
```

#### 2. 依赖更新
```bash
# 前端依赖更新
npm outdated                             # 检查过时依赖
npm update                               # 更新依赖
npm audit fix                            # 修复安全漏洞

# 后端依赖更新
pip list --outdated                     # 检查过时依赖
pip install --upgrade package_name      # 更新特定包
pip-review --local --interactive        # 交互式更新
```

#### 3. 文档更新
```markdown
# 维护日志模板
## [版本号] - [日期]

### 新增功能
- 新增足球场景分析器
- 添加Kinect深度摄像头支持

### 修复问题
- 修复内存泄漏问题
- 解决摄像头索引错误

### 性能优化
- 优化模型推理速度
- 改进前端渲染性能

### 技术债务
- 重构姿态估计模块
- 更新依赖包版本
```

### 监控与日志

#### 1. 系统监控
```python
# monitoring/system_monitor.py
import psutil
import logging
from datetime import datetime

class SystemMonitor:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def log_system_status(self):
        """记录系统状态"""
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        status = {
            'timestamp': datetime.now().isoformat(),
            'cpu_percent': cpu_percent,
            'memory_percent': memory.percent,
            'memory_available': memory.available,
            'disk_percent': disk.percent,
            'disk_free': disk.free
        }
        
        self.logger.info(f"系统状态: {status}")
        
        # 异常状态告警
        if cpu_percent > 80:
            self.logger.warning(f"CPU使用率过高: {cpu_percent}%")
        if memory.percent > 80:
            self.logger.warning(f"内存使用率过高: {memory.percent}%")
        if disk.percent > 90:
            self.logger.error(f"磁盘空间不足: {disk.percent}%")
    
    def monitor_processes(self):
        """监控进程状态"""
        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
            try:
                if proc.info['cpu_percent'] > 50:
                    self.logger.warning(f"高CPU进程: {proc.info}")
                if proc.info['memory_percent'] > 10:
                    self.logger.warning(f"高内存进程: {proc.info}")
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
```

#### 2. 应用日志
```python
# utils/logger.py
import logging
import sys
from pathlib import Path

def setup_logger(name: str, log_file: str = None, level: int = logging.INFO):
    """设置日志记录器"""
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    # 避免重复添加处理器
    if logger.handlers:
        return logger
    
    # 控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)
    
    # 文件处理器
    if log_file:
        log_path = Path(log_file)
        log_path.parent.mkdir(parents=True, exist_ok=True)
        
        file_handler = logging.FileHandler(log_file)
        file_formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
        )
        file_handler.setFormatter(file_formatter)
        logger.addHandler(file_handler)
    
    return logger

# 使用示例
logger = setup_logger('pose_monitoring', 'logs/app.log')
logger.info("应用启动")
```

#### 3. 性能监控
```python
# monitoring/performance_monitor.py
import time
import functools
from typing import Callable

def performance_monitor(func: Callable) -> Callable:
    """性能监控装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        execution_time = end_time - start_time
        logger.info(f"{func.__name__} 执行时间: {execution_time:.3f}s")
        
        # 性能告警
        if execution_time > 1.0:
            logger.warning(f"{func.__name__} 执行时间过长: {execution_time:.3f}s")
        
        return result
    return wrapper

# 使用示例
@performance_monitor
def process_frame(frame):
    # 处理逻辑
    return processed_frame
```

### 备份与恢复

#### 1. 数据备份脚本
```bash
#!/bin/bash
# backup.sh - 数据备份脚本

BACKUP_DIR="/backup/pose_monitoring"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="backup_${DATE}.tar.gz"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份数据库
mysqldump -u username -p password pose_monitoring > $BACKUP_DIR/db_${DATE}.sql

# 备份配置文件
tar -czf $BACKUP_DIR/config_${DATE}.tar.gz \
    multi_scene_monitoring/config/ \
    front-end/.env \
    front-end/vite.config.ts

# 备份模型文件
tar -czf $BACKUP_DIR/models_${DATE}.tar.gz \
    multi_scene_monitoring/*.pth \
    multi_scene_monitoring/*.pt

# 创建完整备份
tar -czf $BACKUP_DIR/$BACKUP_FILE \
    $BACKUP_DIR/db_${DATE}.sql \
    $BACKUP_DIR/config_${DATE}.tar.gz \
    $BACKUP_DIR/models_${DATE}.tar.gz

# 清理旧备份（保留30天）
find $BACKUP_DIR -name "backup_*.tar.gz" -mtime +30 -delete

echo "备份完成: $BACKUP_DIR/$BACKUP_FILE"
```

#### 2. 自动化备份
```python
# backup/auto_backup.py
import schedule
import subprocess
import logging
from datetime import datetime

class AutoBackup:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def backup_database(self):
        """备份数据库"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_file = f"backup_db_{timestamp}.sql"
            
            cmd = [
                'mysqldump',
                '-u', 'username',
                '-ppassword',
                'pose_monitoring'
            ]
            
            with open(backup_file, 'w') as f:
                subprocess.run(cmd, stdout=f, check=True)
            
            self.logger.info(f"数据库备份完成: {backup_file}")
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"数据库备份失败: {e}")
    
    def backup_files(self):
        """备份重要文件"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_file = f"backup_files_{timestamp}.tar.gz"
            
            import tarfile
            with tarfile.open(backup_file, 'w:gz') as tar:
                tar.add('multi_scene_monitoring/models/')
                tar.add('front-end/src/config/')
                tar.add('logs/')
            
            self.logger.info(f"文件备份完成: {backup_file}")
            
        except Exception as e:
            self.logger.error(f"文件备份失败: {e}")
    
    def run_backup(self):
        """执行完整备份"""
        self.logger.info("开始自动备份")
        self.backup_database()
        self.backup_files()
        self.logger.info("自动备份完成")

# 设置定时任务
backup_scheduler = AutoBackup()
schedule.every().day.at("02:00").do(backup_scheduler.run_backup)

while True:
    schedule.run_pending()
    time.sleep(60)
```

### 版本管理

#### 1. 版本发布流程
```bash
#!/bin/bash
# release.sh - 版本发布脚本

VERSION=$1
if [ -z "$VERSION" ]; then
    echo "请提供版本号: ./release.sh v1.0.0"
    exit 1
fi

echo "开始发布版本 $VERSION"

# 1. 运行测试
echo "运行测试..."
npm test
python -m pytest tests/

# 2. 代码质量检查
echo "代码质量检查..."
npm run lint
flake8 multi_scene_monitoring/

# 3. 构建项目
echo "构建项目..."
npm run build

# 4. 创建Git标签
echo "创建Git标签..."
git add .
git commit -m "Release $VERSION"
git tag -a $VERSION -m "Release version $VERSION"
git push origin main
git push origin $VERSION

# 5. 生成发布包
echo "生成发布包..."
mkdir -p dist
tar -czf dist/pose_monitoring_${VERSION}.tar.gz \
    --exclude='.git' \
    --exclude='node_modules' \
    --exclude='__pycache__' \
    --exclude='.pytest_cache' \
    .

echo "版本 $VERSION 发布完成!"
```

#### 2. 版本配置管理
```python
# version.py
import json
from pathlib import Path

class VersionManager:
    def __init__(self):
        self.version_file = Path(__file__).parent / 'version.json'
        self.version_data = self._load_version()
    
    def _load_version(self):
        """加载版本信息"""
        if self.version_file.exists():
            with open(self.version_file, 'r') as f:
                return json.load(f)
        return {
            'version': '1.0.0',
            'build': '1',
            'release_date': None
        }
    
    def get_version(self):
        """获取当前版本"""
        return f"{self.version_data['version']}.{self.version_data['build']}"
    
    def increment_build(self):
        """递增构建号"""
        self.version_data['build'] = str(int(self.version_data['build']) + 1)
        self._save_version()
    
    def set_release_version(self, version: str):
        """设置发布版本"""
        self.version_data['version'] = version
        self.version_data['build'] = '1'
        self.version_data['release_date'] = datetime.now().isoformat()
        self._save_version()
    
    def _save_version(self):
        """保存版本信息"""
        with open(self.version_file, 'w') as f:
            json.dump(self.version_data, f, indent=2)

# 使用示例
version_manager = VersionManager()
print(f"当前版本: {version_manager.get_version()}")
```

---

## 总结

本文档详细介绍了青少年体态监测与篮球动作矫正系统的技术架构、开发指南、部署方案和维护策略。该系统结合了现代Web技术和计算机视觉技术，为青少年体育训练提供了智能化的分析和指导工具。

### 主要特点

1. **技术先进**: 采用React 19、TypeScript、PyTorch等现代化技术栈
2. **架构清晰**: 前后端分离，模块化设计，易于扩展和维护
3. **功能完整**: 涵盖姿态估计、动作分析、数据可视化、报告生成等完整功能
4. **性能优化**: 多进程架构、GPU加速、缓存机制等优化策略
5. **易于部署**: 提供详细的部署指南和故障排除方案

### 应用前景

该系统可广泛应用于：
- 体育训练机构的智能化改造
- 学校体育教学的辅助工具
- 家庭训练的科学指导
- 专业运动员的技术分析

随着人工智能和计算机视觉技术的不断发展，该系统具有广阔的升级空间和应用前景。
